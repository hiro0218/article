---
title: 'buttonはdivで代用できる'
date: 2024-12-01T15:01:00Z
updated:
note: >
  本稿は、[ZOZO Advent Calendar 2024](https://qiita.com/advent-calendar/2024/zozo) シリーズ 1の2日目の記事です。
tags:
  - HTML
  - CSS
  - Advent Calendar
  - アクセシビリティ
---

## buttonをdivで代用はできるが、覚悟が必要

`button[type="button"]`と同等のものを`div`で代用は可能だが、実装には覚悟が必要である。

### 通常のボタン

```html
<button type="button" onClick="alert('Clicked!')">Pure Div Button</button>
```

### divで代用したボタン

```tsx
import { useState, ReactNode, useCallback, KeyboardEvent, MouseEvent, HTMLAttributes } from 'react';

import { createRoot } from 'react-dom/client';

const Button = ({ onClick, children, disabled = false, ...props }: ButtonProps) => {
  // pressed状態の管理
  const [isPressed, setIsPressed] = useState(false);

  // キーボードイベントのハンドラー
  const handleKeyDown = useCallback(
    (e: KeyboardEvent<HTMLDivElement>) => {
      if (disabled) return;

      if (e.key === ' ' || e.key === 'Enter') {
        e.preventDefault();
        setIsPressed(true);
        onClick?.(e as unknown as MouseEvent<HTMLDivElement>);
      }
    },
    [onClick, disabled],
  );

  // keyupハンドラーを追加
  const handleKeyUp = useCallback((e: KeyboardEvent<HTMLDivElement>) => {
    if (e.key === ' ' || e.key === 'Enter') {
      setIsPressed(false);
    }
  }, []);

  const handleClick = (e: MouseEvent<HTMLDivElement>) => {
    if (disabled) return;
    onClick?.(e);
  };

  return (
    <div
      {...props}
      role="button"
      tabIndex={disabled ? -1 : 0}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      onKeyUp={handleKeyUp}
      aria-disabled={disabled}
      aria-pressed={isPressed}
      className={`
        inline-block px-4 py-2
        text-sm
        bg-blue-500 text-white
        rounded cursor-pointer select-none
        transition-all duration-200

        /* ホバー時のスタイル */
        hover:bg-blue-600

        /* フォーカス時のスタイル */
        focus:outline-none
        focus:ring-2
        focus:ring-blue-400
        focus:ring-offset-2

        /* アクティブ時のスタイル */
        active:bg-blue-700

        /* 非活性時のスタイル */
        ${
          disabled &&
          `
          bg-gray-200
          text-gray-400
          cursor-not-allowed
          hover:bg-gray-200
          hover:shadow-none
          focus:ring-0
          focus:ring-offset-0
          pointer-events-none
          opacity-80
        `
        }
      `}
    >
      {children}
    </div>
  );
};

const App = () => {
  return (
    <>
      <Button onClick={() => alert('Clicked!')}>Pure Div Button</Button>
      <Button disabled onClick={() => alert('Clicked!')}>
        Pure Div Button (disabled)
      </Button>
    </>
  );
};

const rootElement = document.getElementById('root');
if (rootElement) {
  const root = createRoot(rootElement);
  root.render(<App />);
}
```

※スタイルは説明を割愛するためTailwind CSSを使用している。

`button`要素と同等の機能をある程度同じものを実装するだけでもこれぐらいは実装しなければならない。

## 解説

`button type="button"` の代わりに`div`を使って同等の機能を実装するためには、以下の考慮が必要となる。

<figure>
  <iframe height="300" style="width: 100%;" scrolling="no" title="Div Button" src="https://codepen.io/hiro0218/embed/GRVXwZE?default-tab=&theme-id=light" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
    See the Pen <a href="https://codepen.io/hiro0218/pen/GRVXwZE">
    Div Button</a> by hiro (<a href="https://codepen.io/hiro0218">@hiro0218</a>)
    on <a href="https://codepen.io">CodePen</a>.
  </iframe>
  <figcaption>デモ</figcaption>
</figure>

### アクセシビリティの問題

`button`要素はインタラクティブな要素なため、フォーカスが可能である。一方で`div`要素は、デフォルトでインタラクティブな要素ではないため、フォーカスはできず、スクリーンリーダーなどの支援技術から適切に認識されない。

#### role属性の設定

`role="button"`を設定するとスクリーンリーダーなどの支援技術に対して要素をボタンとして識別する。

```html
<div role="button"></div>
```

#### フォーカス可能な設定

`button`要素はデフォルトでフォーカス可能だが、`div`だとデフォルトではフォーカスされない。それは`role="button"`を設定しても変わらない。そのため、`tabindex="0"`を設定することでキーボードでのフォーカス移動が可能な状態にする。

```html
<div role="button" tabindex="0"></div>
```

```tsx
// リアクティブにする場合
const Button = () => {
  return <div role="button" tabIndex={disabled ? -1 : 0} />;
};
```

`tabIndex`の値については、`-1`はフォーカス可能だがタブキーでのフォーカス移動ができない状態、`0`はタブキーでのフォーカス移動が可能な状態を表す。

### フォーカススタイルの追加

div要素はデフォルトでフォーカススタイルを持っていない。キーボードナビゲーションを使用するユーザーがどの要素にフォーカスしているかを視覚的に示すために、カスタムのフォーカススタイルを追加する必要がある。

```css
div:focus {
  outline: 2px solid blue;
}
```

```html
<!-- Tailwind CSSを使用する場合 -->
<div class="focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-offset-2"></div>
```

### キーボードイベント

`button`要素は`Enter`や`Space`キーで操作できることが期待される。しかし、`div`要素に`role="button"`を付与しただけでは`Enter`や`Space`キーで操作ができない。

`Enter`や`Space`キーが押された時にクリックイベントを発火させるためには、`onKeyDown`イベントでこれらのキーが押された際にクリックイベントを発火させる必要がある。

```ts
const handleKeyDown = useCallback(
  (e: KeyboardEvent) => {
    if (e.key === ' ' || e.key === 'Enter') {
      e.preventDefault(); // デフォルトのスクロールなどを防止
      onClick?.(e as unknown as MouseEvent); // クリックイベント発火
    }
  },
  [onClick],
);
```

### 視覚的な押下状態の設定

#### aria-disabled

`aria-disabled`は、要素が無効状態であることをスクリーンリーダーに伝える。

```html
aria-disabled={disabled}
```

`disabled`状態の場合は、`aria-disabled="true"`を設定する。

#### aria-pressed

`aria-pressed`は、トグルボタンの現在の状態をスクリーンリーダーに伝える。

```html
aria-pressed={isPressed}
```

```tsx
const [isPressed, setIsPressed] = useState(false);

const handleKeyDown = useCallback(
  (e: KeyboardEvent) => {
    if (disabled) return;
    if (e.key === ' ' || e.key === 'Enter') {
      setIsPressed(true); // pressed状態を更新
      // ...
    }
  },
  [onClick, disabled],
);

const handleKeyUp = useCallback((e: KeyboardEvent) => {
  if (e.key === ' ' || e.key === 'Enter') {
    setIsPressed(false); // pressed状態をリセット
  }
}, []);
```

今回はマウスやキーボードでボタンが押された際の視覚的なフィードバック（`active`状態）を再現するため、`isPressed`という状態を追加して管理し、押下時にスタイルを変更する。

## もしtype="submit"を考慮する場合

ここまで`button type="button"`の仕様をベースに`div`を再現しようとしていたが、仮に`button type="submit"`も考慮する場合は他にも考慮が必要になる。

例えば`type="submit"`の場合、フォーム内で**Enterキー押下時に自動的に送信される機能**があるため、それを実装する必要がある。

1. **フォーム要素の送信処理**
   - `div`がクリックされた際、またはキーボードでのEnterキー押下時に、フォーム全体を`submit`する処理
   - `onClick`や`onKeyDown`イベントで、親フォームの`submit`関数を呼び出す
2. **親フォームの参照取得**

   - Reactの場合は`useRef`を使い`div`要素から親フォームを取得できるようにする  
     `closest('form')`を使って親フォームを動的に見つけ、そのフォームの`submit()`メソッドを呼び出す

     ```ts
     const handleClick = (e: MouseEvent) => {
       const form = (e.target as HTMLElement).closest('form');
       if (form) {
         form.requestSubmit(); // フォームを送信
       }
     };

     const handleKeyDown = (e: KeyboardEvent) => {
       if (e.key === 'Enter') {
         e.preventDefault();
         const form = (e.target as HTMLElement).closest('form');
         if (form) {
           form.requestSubmit();
         }
       }
     };
     ```

   - JavaScript の場合は、親にさかのぼって`form`要素を取得し、`submit()`メソッドを呼び出す

     ```ts
     const handleClick = (e: MouseEvent) => {
       const form = (e.target as HTMLElement).closest('form');
       if (form) {
         form.submit(); // フォームを送信
       }
     };
     ```

このように単なる`button type="button"`とは異なり、`button type="submit"`の場合はフォームの送信処理を考慮する必要がある。

## まとめ

リンクがボタンの機能を持つ場合、要素に`role="button"`を付与することで支援技術を使用するユーザーが要素の機能を理解できる。しかし、`role`属性だけで解決するのではなく、視覚デザインを調整して機能とARIAロールに一致させることが一番である。そのため、可能な限りネイティブのボタン（`<button>`、`<input type="button>`、`<input type="submit>`、`<input type="reset>`、`<input type="image>`）を使用することを推奨する。ネイティブのボタンはすべてのブラウザと支援技術でサポートされており、カスタマイズなしでキーボードとフォーカスの要件を満たしているからである。

## 参考

- [ARIA: button ロール](https://developer.mozilla.org/ja/docs/Web/Accessibility/ARIA/Roles/button_role)
- [HTMLFormElement: requestSubmit() メソッド](https://developer.mozilla.org/ja/docs/Web/API/HTMLFormElement/requestSubmit)
  - [HTMLFormElement: reportValidity() メソッド](https://developer.mozilla.org/ja/docs/Web/API/HTMLFormElement/reportValidity)
