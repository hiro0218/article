---
title: '[CSS in JS] スタイル上書き可能なコンポーネント設計'
date: 2026-01-01T09:18:39Z
updated:
tags:
  - CSS
  - CSS in JS
  - Emotion
  - 設計
---

## 背景

UIライブラリや大規模プロジェクトでコンポーネントを作成する際、利用者によるスタイルのカスタマイズは避けられない。コンポーネント側で上書き用のpropsやスタイルAPIを提供していなければ、利用者は詳細度の競争や内部実装への依存を強いられる。CSS in JSの設計によっては、この上書きが難しくなる。

## 課題

### スタイル上書きの困難性

スタイル定義とコンポーネントが密結合していると、利用者のスタイル上書きが難しい。

```tsx
import styled from '@emotion/styled';

const StyledButton = styled.button`
  background-color: blue;
`;

export function Button({ className, ...props }) {
  return (
    <StyledButton className={className} {...props}>
      Click me
    </StyledButton>
  );
}
```

利用者が`styled(Button)`でスタイルを上書きしようとしても、詳細度の問題で失敗する可能性がある。そもそもコンポーネントがclassNameを受け渡していなければ、`styled()`によるラップ自体が機能しない。また、ライブラリ側で`&&&`や`!important`を使っていると、詳細度の競合が発生する。

```tsx
// 利用者側のコード
import { Button } from 'ui-library';
import styled from '@emotion/styled';

const CustomButton = styled(Button)`
  background-color: red; // ライブラリ側で &&& や !important を使うと反映されない
`;
```

このアプローチの問題点は次の通りだ。

1. **内部実装への依存**: 利用者がライブラリの内部実装（詳細度）に依存し、カプセル化を破壊する
2. **保守性の低下**: ライブラリのバージョンアップで詳細度が変わると、利用者側のコードが壊れる
3. **スケーラビリティの欠如**: プロジェクト全体で詳細度の知識を共有する必要があり、チーム開発の負担になる

利用者側の対処療法であり、ライブラリ側の設計として不適切だ。

詳細度を上げる方法として`&&&`（トリプルアンパサンド）があるが、ライブラリ側の詳細度は不透明だ。利用者は試行錯誤するか実装を確認する必要があり、詳細度の競争は望ましくない。

```tsx
// 利用者に詳細度の知識を要求してしまう
const CustomButton = styled(Button)`
  &&& {
    background-color: red;
  }
`;
```

## 解決方法

UIライブラリや大規模プロジェクトでは、スタイル定義とコンポーネントを分離してエクスポートする。利用者はスタイルを上書きでき、詳細度の競合も回避できる。なお、テーマ拡張やGlobalスタイルとの併用も可能だが、本記事では最もシンプルな分離パターンを紹介する。

### UIライブラリ側の実装

```tsx
import { css } from '@emotion/react';
import type { ComponentProps } from 'react';

// ✅ 推奨パターン：スタイルを分離してエクスポート
export const buttonStyle = css`
  background-color: blue;
  padding: 8px 16px;
  border-radius: 4px;
`;

type ButtonProps = ComponentProps<'button'>;

export function Button({ children, ...props }: ButtonProps) {
  return (
    <button css={buttonStyle} {...props}>
      {children}
    </button>
  );
}
```

この実装は小規模プロジェクト向けだ。中規模以上では、スタイルを別ファイルに分離しつつ、ディレクトリ単位でコロケーション（関連ファイルの近接配置）を維持すれば、コンポーネントとスタイルの関連性を保てる。

```
components/
  Button/
    index.tsx        # コンポーネント
    styles.ts        # スタイル定義
```

```tsx
// styles.ts
import { css } from '@emotion/react';

export const buttonStyle = css`
  background-color: blue;
  padding: 8px 16px;
  border-radius: 4px;
`;
```

```tsx
// index.tsx
import type { ComponentProps } from 'react';
import { buttonStyle } from './styles';

// スタイルを再エクスポート
export { buttonStyle } from './styles';

type ButtonProps = ComponentProps<'button'>;

export function Button({ children, ...props }: ButtonProps) {
  return (
    <button css={buttonStyle} {...props}>
      {children}
    </button>
  );
}
```

### 利用者側のコード

小規模・中規模どちらのファイル構成でも、使い方は同じだ。

```tsx
// 利用者側のコード
import { buttonStyle } from 'ui-library';
import { css } from '@emotion/react';

// スタイルを上書き
const customButtonStyle = css`
  ${buttonStyle}
  background-color: red;
`;

function CustomButton() {
  return <button css={customButtonStyle}>Custom Button</button>;
}

// 配列で合成する方法も可能（後の要素が優先）
function AnotherCustomButton() {
  const overrideStyle = css`
    background-color: red;
  `;
  return <button css={[buttonStyle, overrideStyle]}>Custom Button</button>;
}
```

なお、`@emotion/react`の`css` propでは、className経由のスタイルがcss propのスタイルを上書きする仕様である。

## トレードオフ

### メリット

- スタイルの上書きが容易
- 詳細度の競合を回避
- 必要な部分のみ上書き可能

### デメリット

- コンポーネント単体でスタイルが完結しなくなる（ディレクトリ単位のコロケーションで関連性は保持可能）
- スタイルの粒度設計が必要
- スタイルAPIのドキュメント整備が必須
- 利用者がエクスポートされたスタイルの内部構造を把握する必要がある
- 意図しない上書きのリスク

## 参考

- [Emotion 公式ドキュメント - Composition](https://emotion.sh/docs/composition)
- [styled-components 公式ドキュメント - Extending Styles](https://styled-components.com/docs/basics#extending-styles)
- [styled-components FAQ - How can I override styles with higher specificity?](https://styled-components.com/docs/faqs#how-can-i-override-styles-with-higher-specificity)
