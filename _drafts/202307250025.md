---
title: '[JavaScript] Map、Set、WeakMap、WeakSet の違いとユースケースについて'
date: 2023-07-24T15:25:35Z
updated:
tags:
  - JavaScript
---

## 特徴

### `Map`

- **概要**: 
  - `Map`はキーと値のペアを保存するコレクションである。オブジェクトと異なり、任意のタイプのキーを持つことができる。
- **ユースケース**:
  - オブジェクトとは異なるキーのタイプを使用したい場合（例: オブジェクトや関数をキーとして使用する場合）。
  - キーの挿入順序を保持する必要がある場合。
  - キーの存在を確認しやすくするため、またはキーと値を効率的に反復処理するため。

```js
let map = new Map();
map.set('name', '山田');
map.set('age', 30);

console.log(map.get('name')); // "山田"
console.log(map.has('age')); // true
```

### `Set`

- **概要**: 
  - `Set`は重複する値を持たない要素のコレクションである。
- **ユースケース**:
  - 重複する要素を削除する必要がある場合（例: 配列から重複する要素を取り除く場合）。
  - ある要素がコレクションに存在するかを高速に確認する場合。

```js
let set = new Set();
set.add(10);
set.add(20);
set.add(10); // この値は追加されない

console.log(set.size); // 2
```

### `WeakMap`

- **概要**: 
  - `WeakMap`はキーとしてオブジェクトのみを持ち、そのオブジェクトへの参照が弱い特性を持つマップである。これにより、キーとしてのオブジェクトがガベージコレクションの対象となると、対応するエントリも自動的に削除される。
- **ユースケース**:
  - 主要なオブジェクトとそれに関連するメタデータや補助データを関連付けたい場合、かつその補助データが主要なオブジェクトの生存期間に依存している場合。
  - オブジェクトの拡張やプライベートデータの格納など、オブジェクトのライフサイクルに関連した操作を行いたい場合。

```js
let weakmap = new WeakMap();
let obj = {};
weakmap.set(obj, '私はオブジェクトのメタデータです');

obj = null; // objへの参照を解除すると、WeakMap内のエントリも自動的に削除される
```

### `WeakSet`

- **概要**: 
  - `WeakSet`はオブジェクトのみを要素として持ち、そのオブジェクトへの参照が弱い特性を持つセットである。これにより、セットの要素としてのオブジェクトがガベージコレクションの対象となると、その要素も自動的に削除される。
- **ユースケース**:
  - あるオブジェクトが特定のセットに存在するかどうかを追跡したい場合、かつその追跡の状態がオブジェクトのライフサイクルに依存している場合。
  - 重複を防ぎつつ、ガベージコレクションによる自動的なリソース解放を希望する場合。

```js
let weakset = new WeakSet();
let obj = {};
weakset.add(obj);

obj = null; // objへの参照を解除すると、WeakSet内のエントリも自動的に削除される
```

## Objectとの比較

`Object`と上述のデータ構造（`Map`, `Set`, `WeakMap`, `WeakSet`）を比較すると、パフォーマンスや使用上の違いが見受けられる。以下にそれらの違いに基づくユースケースやパフォーマンスの観点からの考察を示す。

### Object vs Map

- **キーの種類**: `Object`は主に文字列とシンボルをキーとして使用する。一方、`Map`は任意のデータ型をキーとして持つことができる。
- **挿入順序**: `Map`はキーの挿入順序を保持するが、`Object`はそれを保証しない（ただし、最近のJSエンジンでは順序を維持する実装が多い）。
- **パフォーマンス**: キーの存在を確認する操作やキーと値の挿入・削除など、動的な操作において`Map`は高速に動作することが設計されている。
- **ユースケース**: `Map`はキーの挿入順序を保持する必要がある場合や、非文字列キーを使用したい場合に有利である。`Object`は静的なキーのセットやJSONとの相互変換が必要な場合に適している。

### Object vs Set

`Object`と`Set`の比較は少し不均衡である。なぜなら、`Object`はキーと値のペアを保存するのに対して、`Set`は単一の値のコレクションを扱うからだ。

- **ユースケース**: `Set`は主に要素の存在を追跡するために使用される。特定の値がすでに存在するかどうかを高速に確認できる。`Object`はキーと値のペアの保存が必要な場合に使用される。

### WeakMap vs Object

- **メモリ管理**: `WeakMap`の最大の特徴は、キーとしてのオブジェクトがガベージコレクションの対象となった場合、そのキーに関連するエントリも自動的に削除されることである。`Object`にはそのような特性はない。
- **ユースケース**: `WeakMap`はオブジェクトに関連する一時的なメタデータや、メモリリークを避けるためのデータの保存に適している。一方、`Object`は永続的なキーと値のマッピングが必要な場合に使用される。

### WeakSet vs Object

`WeakSet`はオブジェクトの存在を追跡するためのセットである。`Object`とは目的が異なる。

- **ユースケース**: `WeakSet`は特定のオブジェクトがセットに存在しているかどうかを追跡する場合、特にそのオブジェクトがほかの場所で参照されなくなったときに自動的に削除することが求められる場合に適している。`Object`はキーと値のマッピングが中心の用途である。

---

結論として、これらのデータ構造の選択は、特定のタスクやユースケースに応じて行うべきである。特定の性能要件やメモリ管理の要件がある場合、適切なデータ構造を選択することで最適な結果を得ることができる。
