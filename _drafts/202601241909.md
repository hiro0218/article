---
title: '過剰な抽象化を避ける実装論としてのAHA Programming'
date: 2026-01-24T10:09:11Z
updated:
tags:
  - 設計
---

## TL;DR

AHAは「**A**void **H**asty **A**bstractions（性急な抽象化を避けよ）」の略である。Kent C. Doddsが提唱した。

https://kentcdodds.com/blog/aha-programming

核心は Sandi Metz の言葉に集約される。

> **「間違った抽象化よりも、重複を選べ」**

これは「抽象化するな」ではなく「**確信が持てるまで待て**」という意味である。

> [!NOTE]
> 本記事は原文の解説に加え、筆者による具体例（商品カードの実装比較）、実践的な手順、およびLLM時代の考察を含んでいる。

### 3つの指針

1. **重複を恐れない**：最初から抽象化しない。重複はそのままにする。
2. **パターンを観察する**：重複が増えたとき、共通点と相違点の境界線を見極める。
3. **確信が持てたら抽象化する**：境界の明確化により抽象化を行う。

### DRY・WET・AHAの比較

| 原則 | スタンス                 | 問題点                     |
| ---- | ------------------------ | -------------------------- |
| DRY  | 重複を見たら即座に排除   | 早すぎる抽象化を招く       |
| WET  | 2回までの重複を許容      | 回数は本質的な基準ではない |
| AHA  | 正しい形が見えるまで待つ | ー                         |

## 問題点

なぜ早すぎる抽象化は問題なのか。

### 抽象化は予測である

抽象化を行うとき、開発者は以下を暗黙的に予測している。

- この共通部分は今後も共通のままである
- 新しいユースケースはこの枠組みに収まる
- 違いはパラメータで吸収できる

この予測は外れることが多い。抽象化時点では2〜3個のユースケースしか見えておらず、将来のユースケースがその想定内に収まる保証はない。

### 間違った抽象化が生まれるプロセス

Sandi Metz による分析：

```text
1. 開発者Aが重複を発見し、抽象化する
2. 開発者Aは満足して去る
  ↓（時間経過）
3. 新要件が発生、既存の抽象化が「ほぼ」適合する
4. 開発者Bがパラメータと条件分岐を追加
  ↓（繰り返し）
5. 条件分岐だらけの保守困難なコードが完成
```

各ステップで誰も間違ったことをしていない。開発者Aは正しくDRYを適用し、開発者Bは既存の抽象化を尊重した。しかし結果として保守困難なコードが生まれる。

### 重複 vs 間違った抽象化のコスト比較

| コスト種別 | 重複コード                   | 間違った抽象化                     |
| ---------- | ---------------------------- | ---------------------------------- |
| 増加のし方 | 線形（3箇所なら3箇所修正）   | 指数的（条件分岐が絡み合う）       |
| 影響範囲   | 自明（修正したファイルのみ） | 不明（どこに影響するか分からない） |
| 認知負荷   | 低い（具体的で読める）       | 高い（抽象を理解する必要がある）   |

## 実例：過度に抽象化された商品カード

過度な抽象化が引き起こす問題を、具体的なコード例で示す。

### 状況

ECサイトの商品カードコンポーネント。「通常商品」「セール商品」「予約商品」「品切れ商品」を汎用的に扱うため、以下の構成で抽象化された。

```text
src/components/ProductCard/
├── ProductCard.tsx / ProductCardContainer.tsx / ProductCardPresenter.tsx
├── hooks/ (3ファイル)
├── strategies/ (5ファイル: Strategy, Normal, Sale, Preorder, Soldout)
├── factories/ (1ファイル)
├── contexts/ (1ファイル)
├── types/
└── utils/ (2ファイル)
```

```typescript
// 過度に抽象化されたストラテジー例（条件分岐が膨らみやすい）
type ProductType = 'normal' | 'sale' | 'preorder' | 'soldout';

type StrategyOptions = {
  highlight?: boolean; // セール中かを暗黙で表現
  allowBackorder?: boolean; // 予約専用の分岐
  forceDisable?: boolean; // 品切れを表現
};

export const buildProductStrategy = (type: ProductType, options: StrategyOptions) => {
  if (type === 'sale' && options.highlight) return 'sale-with-highlight';
  if (type === 'preorder' && options.allowBackorder) return 'preorder-open';
  if (options.forceDisable) return 'soldout';
  return type; // 追加条件が増えるたびに複雑化する
};
```

Strategy パターン、Factory パターン、Container/Presenter パターンが適用されている。一見すると整理された設計に見える。

### 問題：「限定商品」の追加

新要件：「限定商品」タイプを追加する。LIMITEDバッジ、残り個数表示、金色の購入ボタン。

#### どこを修正すればよいか分からない

- 新しい Strategy を作る？限定商品がセール中の場合は？
- Factory の条件分岐のどこに挿入する？優先度は？
- バッジロジックは Strategy にある？productHelpers.ts にある？
- 残り個数表示は getDescription？新しいフィールド？
- ボタン色は useProductCardState？Strategy の getButtonStyle？

#### 影響範囲

最低でも以下のファイルの修正が必要である。

```text
types/index.ts
strategies/LimitedProductStrategy.ts（新規）
strategies/ProductStrategy.ts
hooks/useProductCard.ts
...他5ファイル（計8ファイル以上の修正が必要）
```

既存4タイプへの影響がないことも確認が必要。

### AHA的アプローチ：重複を許容した設計

```text
src/components/
├── NormalProductCard.tsx
├── SaleProductCard.tsx
├── PreorderProductCard.tsx
├── SoldoutProductCard.tsx
└── LimitedProductCard.tsx（新規追加）
```

```tsx
// SaleProductCard.tsx: セール専用の責務に閉じる
export const SaleProductCard: React.FC<Props> = ({ product, onAddToCart }) => (
  <div className="product-card">
    {/* セール価格だけを強調し、他の状態は考えない */}
    <span className="product-card__badge product-card__badge--sale">SALE</span>
    <h3 className="product-card__title">{product.name}</h3>
    <p className="product-card__price">¥{product.salePrice?.toLocaleString()}</p>
    <button type="button" className="product-card__button" onClick={onAddToCart}>
      カートに入れる
    </button>
  </div>
);
```

各ファイルは独立。共通部分は重複しているが、自己完結している。

#### 「限定商品」を追加する場合

```tsx
// LimitedProductCard.tsx: 限定商品を自己完結で表現する
export const LimitedProductCard: React.FC<Props> = ({ product, onAddToCart }) => {
  return (
    <div className="product-card">
      {/* 限定商品を示すバッジ */}
      <span className="product-card__badge product-card__badge--limited">LIMITED</span>
      {/* プロダクト画像 */}
      <img className="product-card__image" src={product.imageUrl} alt={product.name} />
      <h3 className="product-card__title">{product.name}</h3>
      <p className="product-card__description">{product.description}</p>
      {/* 残在庫を即座に見せる */}
      <p className="product-card__stock">残り {product.remainingStock} 点</p>
      <p className="product-card__price">¥{product.price.toLocaleString()}</p>
      {/* 金色ボタンで限定感を強調 */}
      <button type="button" className="product-card__button product-card__button--gold" onClick={onAddToCart}>
        カートに入れる
      </button>
    </div>
  );
};
```

修正ファイル：1つ（新規作成）。他コンポーネントへの影響なし。

### 比較

| 観点               | 過度な抽象化            | 重複許容                   |
| ------------------ | ----------------------- | -------------------------- |
| 新機能追加         | 8ファイル以上修正       | 1ファイル新規作成          |
| バグ修正           | 特定困難                | 該当ファイルを直す         |
| コードリーディング | 6層以上を行き来         | 1ファイルで完結            |
| 共通部分の修正     | 1箇所（ただし影響不明） | 複数ヵ所（ただし影響自明） |

## 対応方法

間違った抽象化から回復するための手順を示す。

### ステップ1：インライン展開

抽象化されたコードを呼び出し元すべてにコピーして戻す。

### ステップ2：不要部分の削除

各呼び出し元で使っていないパラメータや条件分岐を削除する。

### ステップ3：観察

重複コードを眺めて、真に共通するパターンを見つける。前回とは異なる境界線が見えてくる可能性がある。

### ステップ4：再抽象化（必要なら）

十分な情報に基づいて、本当に共通する部分だけを小さく抽象化する。

```tsx
// 本当に共通な部分だけを小さく抽出する
const ProductImage: React.FC<{ src: string; alt: string }> = ({ src, alt }) => (
  // alt を必須にしてアクセシビリティを守る
  <img className="product-card__image" src={src} alt={alt} />
);

const AddToCartButton: React.FC<{ onClick: () => void; modifier?: string }> = ({ onClick, modifier = '' }) => (
  // modifier によってボタンの見た目だけを変える
  <button className={`product-card__button ${modifier ? `product-card__button--${modifier}` : ''}`} onClick={onClick}>
    カートに入れる
  </button>
);
```

```typescript
// インライン展開前：条件分岐が増殖する汎用関数
function renderButton(type: 'normal' | 'sale' | 'preorder', flags: { highlight?: boolean }) {
  if (type === 'sale' && flags.highlight) return 'sale-highlight-button';
  if (type === 'preorder') return 'preorder-button';
  return 'normal-button';
}

// インライン展開後：ケースごとに責務を分割
function renderSaleButton() {
  return 'sale-highlight-button';
}

function renderPreorderButton() {
  return 'preorder-button';
}
```

小さな共通部品を使いつつ、各コンポーネントは独立を維持する。

## 余談：LLM時代における抽象化

LLM時代におけるAHAについても個人的な見解を述べる。

### LLMは抽象化にバイアスがかかっている

**理由1：学習データのバイアス**

学習元（OSSや技術記事）には「DRYを守ったきれいなコード」が多いため、「重複を見たら抽象化する」パターンを強く学習している可能性が高い。

**理由2：コンテキストの限界**

LLMは与えられた情報で最適化するため、以下の点は考慮が難しい。

- プロジェクトの歴史と過去の失敗
- 将来の要件変更の方向性
- 「この重複はあえて残している」という意図

**理由3：「何もしない」を出力しにくい**

LLMは入力に対して何かを出力しようとする。「この重複はあえて残すべき」という判断は出力しにくい。

### LLMへの指示例

悪い指示例：

```text
このコードをリファクタリングしてください。
```

良い指示例：

```text
このコードをリファクタリングしてください。

ただし、以下の点に注意してください：
- UserFormとAdminFormは将来の変更方向が異なるため、
  あえて別コンポーネントにしています
- バリデーションロジックの重複は許容しています
- 早すぎる抽象化を避け、AHAの原則に従ってください
```

### LLMとの協働

1. **LLMの提案を疑う**：「この重複を共通化しました」に対して「本当に共通化すべきか？」を考える
2. **意図を明示する**：「この重複はあえて残している」というコメントをコードに残す
3. **段階的に依頼する**：「まず重複したまま書いて」→「パターンを観察して」→「必要なら抽象化して」

## 参考

- [AHA Programming - Kent C. Dodds](https://kentcdodds.com/blog/aha-programming)
- [The Wrong Abstraction - Sandi Metz](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction)
